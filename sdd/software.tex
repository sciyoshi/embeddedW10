\chapter{Software}

\section{Overview}

The software component of the amplifier system will be running on top of an embedded real-time operating system (such as FreeRTOS). This operating system will provide the task management and scheduling required by the rest of the application. The main software components are shown in DIAGRAM REFERENCE; a description of each can be found in the following sections.

DIAGRAM HERE

\section{Main Task}

displays menu and all that

functions

\section{Input Drivers (Buttons and Scroll Wheel)}

tasks

\section{Digital Amplifier Driver}
The CS4525 uses I\superscript{2}C and a series of single-byte configuration registers for all of its communications. The \emph{Reset} line is used to control power to the amplifier and is only used in initialization and in the case of error conditions. The core functions of this driver therefore are only those for single-byte reads and writes, as well as interrupt handling. Ur

\subsection*{Functions}
\begin{itemize}
\item \texttt{void amp\_init(void)} \\ Initializes I\superscript{2}C channel 1 and loads default values
\item \texttt{void amp\_write\_byte(char addr, char value)} \\ Set a byte in the amplifier registers
\item \texttt{char amp\_read\_byte(char addr)} \\ Set a byte in the amplifier registers
\end{itemize}

\section{EEPROM Driver}
The EEPROM is very simple in function, using a buffer to allow writing of up to 128 bytes at a time.
\subsection*{Functions}
\begin{itemize}
\item \texttt{void e2p\_init(void)} \\ Initializes I\superscript{2}C channel 2
\item \texttt{void e2p\_write\_byte(char addr, char value)} \\ Write a single byte
\item \texttt{char e2p\_read\_byte(char addr)} \\ Read a single byte
\item \texttt{char e2p\_write(char addr, char len, char* buf)} \\ Write an arbitrary amount of data; return count
\item \texttt{char e2p\_read(char addr, char len, char* buf)} \\ Read an arbitrary amount of data; return count
\end{itemize}

\section{LCD Driver}

The LCD driver is controlled using a list of functions that write to the LCD board in different ways. There is a function that writes a new line, a function that writes to a specified column and row, there is a function that writes a single character, a function that can write a single byte, and a function that can clear the screen so that more data can be written to it. The purpose of having all of these different ways to manipulate the LCD screen is two-fold. One, the various functions for writing to the LCD allowed for greater control over the way the user interface is designed. The functionality provided by the LCD interface allows us to implement features like writing non-ASCII characters to the screen (necessary to provide the ability to show a visualization when no music is playing). Second, we can use many of these functions during testing to ensure that the LCD board, and the modules connected to it functioned properly. Additionally the brightness and contrast can be controlled by using a PWM signal. There are additional software functions for controlling these variables by generating different pulse widths for each of these variables based on settings defined through the menu system. These functions together provide a driver interface for the rest of the software to use.

\begin{center}
\begin{tabular}{l|l}
Function & Description \\
\hline
\texttt{void lcd\_init(void)} & Initializes communication with the LCD device \\
\hline
\texttt{void lcd\_init(void)} & Initializes communication with the LCD device \\
\end{tabular}
\end{center}

\section{User Interface}
\label{sec:ui}

One of the more important software design issues that we needed to consider was the user interface (UI). When designing any system that is user-controlled, it is crucial to design a UI that is both simple and effective. We have chosen to make the interface based on a state machine implemented in an event-driven manner, similar to many real-time systems. The structure of this state machine is described in more detail below.

Initially, the system is in the \emph{Main} state. In this state, a user can control the volume using the knob, and the LCD will display the volume level. This display times out after 10 seconds.

As described in \autoref{sec:buttons}, the system also has four available buttons. In any state, the bottom button (the home button) will cause the system to return to the \emph{Main} state. This provides the user with a quick way to exit any menu. The top left button (the mute button) will also work in every state, and will cause the system to either mute or unmute the audio output. The top middle button (the menu/select button) will cause a state-dependent transition corresponding to ``selecting'' a menu option or entering the main menu. The last button (the back button) will take the user to the previous menu. There will be an inactivity timeout (which can be chosen by the user, but defaulted at 30 seconds) after which the system will go back to the \emph{Main} state.

The menu structure corresponds directly to the states in the state machine. These are shown in their logical structure below.

\begin{itemize}

\item \textbf{(M)} Sound
\begin{itemize}
	\item \textbf{(C)} Freq1 (Bass)
	\item \textbf{(C)} Freq2
	\item \textbf{(C)} Freq3 (Mid)
	\item \textbf{(C)} Freq4
	\item \textbf{(C)} Freq5 (Treble)
	\item \textbf{(B)} Enable/Disable Adaptive Loudness Compensation
\end{itemize}

\item \textbf{(M)} System
\begin{itemize}
	\item \textbf{(B)} Enable/Disable Spectrum Analyzer
	\item \textbf{(C)} Screen Contrast
	\item \textbf{(C)} Screen Brightness
\end{itemize}

\item \textbf{(M)} Presets
\begin{itemize}
	\item \textbf{(M)} Load Preset
	\begin{itemize}
		\item \textbf{(A)} Preset 1
		\item \textbf{(A)} Preset 2
		\item \textbf{(A)} Preset 3
	\end{itemize}

	\item \textbf{(M)} Save Preset
	\begin{itemize}
		\item \textbf{(A)} Preset 1
		\item \textbf{(A)} Preset 2
		\item \textbf{(A)} Preset 3
	\end{itemize}
\end{itemize}

\end{itemize}

In this menu description, \textbf{(M)} corresponds to a menu or submenu. When the system is in one of these states, the scroll wheel allows the user to select an appropriate item in the menu, and the menu button activates the selected item. The back button navigates up to the parent state in the tree. \textbf{(B)} corresponds to a boolean option; when activated by pressing the menu button, the option is either enabled or disabled, and the system remains in the same state. \textbf{(C)} represents a continuous parameter; when activated, this displays a value and a graphical indicator of the present value on the LCD. From this state, scrolling the wheel changes the parameter value, and pressing either of the back or menu buttons causes the system to return to the previous state. \textbf{(A)} is an action; when selected, the system performs the appropriate action and returns to the \emph{Main} state.
